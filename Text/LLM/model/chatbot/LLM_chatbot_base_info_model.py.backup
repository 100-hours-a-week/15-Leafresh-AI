from langchain.output_parsers import StructuredOutputParser, ResponseSchema
from langchain.prompts import PromptTemplate
from fastapi import HTTPException
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
import requests
import os
import json
from typing import Generator, Dict, Any

load_dotenv()

# 환경 변수에서 값 가져오기
HF_API_KEY = os.getenv("HUGGINGFACE_API_KEYMAC")
MODEL_NAME = os.getenv("HF_MODEL_NAME", "mistralai/Mistral-7B-Instruct-v0.3")
API_URL = f"https://api-inference.huggingface.co/models/{MODEL_NAME}"

# base-info_response_schemas 정의
base_response_schemas = [
    ResponseSchema(name="recommend", description=f"추천 텍스트를 한 문장으로 출력해줘.(예: '이런 챌린지를 추천합니다.')"),
    ResponseSchema(name="challenges", description="추천 챌린지 리스트, 각 항목은 title, description 포함, description은 한 문장으로 요약해주세요.")
                   ]

# base-info_output_parser 정의 
base_parser = StructuredOutputParser.from_response_schemas(base_response_schemas)

# base-info_prompt 정의
escaped_format = base_parser.get_format_instructions().replace("{", "{{").replace("}", "}}")
base_prompt = PromptTemplate(
    input_variables=["location", "workType", "category"],
    template=f"""<s>[INST] 당신은 환경 보호 챌린지를 추천하는 AI 어시스턴트입니다.
{{location}} 환경에 있는 {{workType}} 사용자가 {{category}}를 실천할 때,
절대적으로 환경에 도움이 되는 챌린지를 아래 JSON 형식으로 3가지 추천해주세요.

주의사항:
1. 모든 속성 이름은 반드시 큰따옴표(")로 둘러싸야 합니다.
2. 모든 문자열 값도 큰따옴표(")로 둘러싸야 합니다.
3. 마지막 항목 뒤에는 쉼표(,)를 붙이지 않습니다.

JSON 포맷:
{escaped_format}

응답은 반드시 한글로 위 JSON형식 그대로 출력하세요. [/INST]</s>
"""
)

def format_sse_response(event: str, data: Dict[str, Any]) -> str:
    """SSE 응답 형식으로 변환"""
    return f"event: {event}\ndata: {json.dumps(data, ensure_ascii=False)}\n\n"

def get_llm_response(prompt: str) -> Generator[str, None, None]:
    """LLM 응답을 SSE 형식으로 반환"""
    try:
        # Hugging Face API로 직접 요청
        headers = {
            "Authorization": f"Bearer {HF_API_KEY}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "inputs": prompt,
            "parameters": {
                "max_new_tokens": 1024,
                "temperature": 0.7,
                "stop": ["</s>", "[INST]"],
                "do_sample": True,
                "return_full_text": False
            }
        }
        
        try:
            response = requests.post(API_URL, headers=headers, json=payload)
            response.raise_for_status()  # HTTP 오류 발생 시 예외 발생
            
            result = response.json()
            
            if not result:
                yield format_sse_response("error", {
                    "status": 502,
                    "message": "모델 응답이 유효하지 않습니다.",
                    "data": None
                })
                return

            raw_text = result
            if isinstance(result, list) and len(result) > 0:
                raw_text = result[0].get("generated_text", "")
            elif isinstance(result, dict):
                if "generated_text" in result:
                    raw_text = result["generated_text"]
                elif "response" in result:
                    raw_text = result["response"]
                elif "message" in result:
                    raw_text = result["message"]["content"]
            
            print(f"Raw model response: {raw_text}")  # 디버깅용 로그

            try:
                # JSON 형식인지 확인
                if raw_text.startswith('{') and raw_text.endswith('}'):
                    parsed = json.loads(raw_text)
                else:
                    # JSON이 아니면 parser 사용
                    parsed = base_parser.parse(raw_text)
                    
                # challenges가 문자열인 경우 JSON으로 파싱
                if isinstance(parsed.get("challenges"), str):
                    try:
                        parsed["challenges"] = json.loads(parsed["challenges"])
                    except json.JSONDecodeError:
                        yield format_sse_response("error", {
                            "status": 400,
                            "message": "challenges 형식이 올바르지 않습니다.",
                            "data": None
                        })
                        return

                # 각 챌린지를 개별 이벤트로 전송
                for idx, challenge in enumerate(parsed["challenges"], 1):
                    yield format_sse_response("challenge", {
                        "status": 200,
                        "message": f"{idx}번째 챌린지 추천",
                        "data": {
                            "challenges": challenge
                        }
                    })

                # 완료 이벤트 전송
                yield format_sse_response("close", {
                    "status": 200,
                    "message": "모든 챌린지 추천 완료",
                    "data": None
                })
                return  # 명시적으로 제너레이터 종료

            except json.JSONDecodeError as json_err:
                print(f"JSON 파싱 오류: {str(json_err)}")
                yield format_sse_response("error", {
                    "status": 400,
                    "message": "응답 형식이 올바르지 않습니다.",
                    "data": None
                })
                return  # 명시적으로 제너레이터 종료

        except requests.exceptions.HTTPError as http_err:
            if http_err.response.status_code == 401:
                print("Hugging Face API 인증 실패")
                yield format_sse_response("error", {
                    "status": 401,
                    "message": "Hugging Face API 인증에 실패했습니다. API 키를 확인해주세요.",
                    "data": None
                })
            elif http_err.response.status_code == 502:
                print("Hugging Face API 서버 오류")
                yield format_sse_response("error", {
                    "status": 502,
                    "message": "AI 서버로부터 응답을 받아오는 데 실패했습니다. 잠시 후 다시 시도해주세요.",
                    "data": None
                })
            else:
                print(f"HTTP 오류: {str(http_err)}")
                yield format_sse_response("error", {
                    "status": http_err.response.status_code,
                    "message": f"API 요청 중 오류가 발생했습니다: {str(http_err)}",
                    "data": None
                })
            return  # 명시적으로 제너레이터 종료

    except ValueError as val_err:
        print(f"값 검증 오류: {str(val_err)}")
        yield format_sse_response("error", {
            "status": 400,
            "message": str(val_err),
            "data": None
        })
        return  # 명시적으로 제너레이터 종료
    except Exception as e:
        print(f"예상치 못한 오류: {str(e)}")
        yield format_sse_response("error", {
            "status": 500,
            "message": "서버 내부 오류로 추천에 실패했습니다.",
            "data": None
        })
        return  # 명시적으로 제너레이터 종료
